const crypto = require('crypto');
const express = require('express');
const router = express.Router();
const { kv } = require('@vercel/kv');
const isAuthenticated = require('../middleware/authenticate');
const { logPayload, hashDataKeccak256, hashTextKeccak256, recoverDataFromWide, signDataAsWide } = require('../web3/web3Connector');
const web3 = require('web3');

router.get('/user/:accountAddress/issued-credentials', isAuthenticated, async (req, res) => {
    try {
        const { accountAddress } = req.params;
        const key = `account:${accountAddress}:issued-credentials`;

        const keyExists = await kv.exists(key);

        if (!keyExists) {
            res.status(204).json([]);
            return;
        }

        const data = await kv.lrange(key, 0, -1);
        if (data) {
            res.status(200).json(data);
        } else {
            res.status(204).json(data);
        }
    } catch (error) {
        console.error('Error retrieving data:', error);
        res.status(500).json('Error retrieving data');
    }
});

router.get('/user/:accountAddress/credentials/:key', isAuthenticated, async (req, res) => {
    try {
        const { accountAddress, key } = req.params;
        const credentialKey = `account:${accountAddress}:credential:${key}`;

        const credentialData = await kv.hgetall(credentialKey);

        if (credentialData) {
            res.status(200).json(credentialData);
        } else {
            res.status(204).json(credentialData);
        }
    } catch (error) {
        console.error('Error retrieving data:', error);
        res.status(500).json('Error retrieving data');
    }
});

router.post('/user/:accountAddress/credential', isAuthenticated, async (req, res) => {
    //TODO: Consider separating into two separate try catch blocks to separate kv storage from web3 errors.
    try {
        const { accountAddress } = req.params;
        const { issuer, payload, credentials } = req.body;
        const rawPayloadHash = req.body.rawPayloadHash; //possible issue with binding the body?

        //Notes:
        //issuer: The dataset representing the Issuer and info on the issuance of the credentials
        //payload: The entire set of credentials ('payload') in encrypted format
        //credentials: The credentials encrypted separately

        const issuerHash = hashDataKeccak256(issuer.issuer);
        //We do not need the entire payload. Ephemeral Key and nonce may remain private for increased security
        //The `hashTextKeccak256(payload.ciphertext)` must be sent with all presentations to allow the RP to verify credential presentation to WIDE
        const encPayloadHash = hashTextKeccak256(payload.ciphertext); 

        const issuersIndexKey = `account:${accountAddress}:issued-credentials`;
        const credentialKey = `account:${accountAddress}:credential:${issuerHash}`

        //add hash (unique identifier) to the issuer.
        //this will allow us to conveniently be able to retrieve the associated data at a later stage.
        const issuerInternalIdProp = { wideInternalId: issuerHash }
        let issuerWithId = { ...issuerInternalIdProp, ...issuer }

        await kv.rpush(issuersIndexKey, issuerWithId);
        await kv.hset(credentialKey, { payload: payload, credentials: credentials });

        //We must canonicalize this payload since its hash is used for RP verification
        const payloadSignatureMessage = {
            publicKey: accountAddress,
            encPayloadHash: encPayloadHash,
            payloadHash: rawPayloadHash
        };
        
        // Call your smart contract here
        const payloadKey = hashDataKeccak256(payloadSignatureMessage); //This may be generated by the RP without knowledge of the payload decrypted contents
        const payloadSignature = await signDataAsWide(payloadSignatureMessage); //This allows the RP to verify that the Wide server has seen it.
      
        //This is for development and debugging purposes - to ensure that the signed message is accurately recoverable
        //const recoveredSignatureFromWide = await recoverDataFromWide(payloadSignatureMessage, payloadSignature);

        // Using the logPayload function from blockchain.js
        await logPayload(payloadKey, payloadSignature);

        //This is for development and debugging purposes.
        // console.log('payloadSignatureMessage', payloadSignatureMessage);
        // console.log('logged payload', payloadKey);

        res.status(200).json(`Data for ${credentialKey} set successfully`);
    } catch (error) {
        console.error('Error setting data:', error);
        res.status(500).json('Error setting data');
    }
});

module.exports = router;